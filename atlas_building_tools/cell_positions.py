'''Functions to generate 3D cell positions for the whole mouse brain.

 Cell positions of the form (x, y, z) in the annotated volume space are generated by means of
 an acceptance-rejection method based on prescribed cell densities.
'''

from typing import List, TYPE_CHECKING
import numpy as np  # type: ignore
from nptyping import NDArray  # type: ignore

if TYPE_CHECKING:  # pragma: no cover
    import voxcell  # type: ignore


def generate_cell_positions(
    annotation_indices: NDArray[int], density_data: 'voxcell.VoxelData'
) -> NDArray[np.float32]:
    '''
    Generate cell positions based on the prescribed input density.

    The input density provides a cell count and a cell distribution to be respected.
    These two constraints are enforced by means of rejection sampling, see
    https://en.wikipedia.org/wiki/Rejection_sampling.

    Args:
        annotation_indices: integer array of shape (N, 3) where N is the total number of
            non-zero annotated voxels. This is a 1D array of voxel multi-indices (x, y, z).
        density_data: VoxelData object holding a float array of shape (W, H, D), the shape of
            the whole mouse brain annotation file. This represents the volumetric density
            i.e., the number of cells per voxel of a given cell type, e.g., a type among
            astrocytes, oligodendrocytes, microglia, excitatory cells, inhibitory cells, ...
            Note: `density_data` is assumed to have the same offset and the same voxel dimensions as
            the annotated volume associated to `annotation_indices`.

    Returns:
        cell positions, a float32 array of shape (M, 3) where M is the sum of the volumetric density
        array held by `density_data`. Each cell position is a vector (X, Y, Z) expressed in the
        `density_data` 3D frame, thus taking the offset and the voxel dimensions into account.
    '''
    np.random.seed(0)
    cell_count = int(np.round(np.sum(density_data.raw)))
    density = density_data.raw / np.max(density_data.raw)
    positions: List[NDArray[np.float32]] = []
    while cell_count != 0:
        sampled_indices = np.random.choice(len(annotation_indices), cell_count)
        sampled_densities = np.random.rand(cell_count)
        accepted = (
            density[tuple(annotation_indices[sampled_indices].T)] > sampled_densities
        )
        accepted = annotation_indices[sampled_indices[accepted]]

        # Generate a random position within each accepted voxel
        accepted_positions = accepted + np.random.rand(len(accepted), 3)

        positions.append(density_data.indices_to_positions(accepted_positions))
        cell_count -= len(accepted_positions)

    return np.concatenate(positions).astype(np.float32)
